1. Подробно прочитать про метод запроса OPTIONS - и кратко его описать, когда вызывается, где используется, что передает и принимает. 

Метод запроса OPTIONS в протоколе HTTP запрашивает информацию об опциях соединения, доступных для конкретного ресурса на сервере.   
Когда клиент отправляет запрос OPTIONS, сервер отвечает списком поддерживаемых HTTP-методов и любых дополнительных опций соединения, специфических для этого ресурса. 
Этот метод не изменяет сам ресурс, а помогает клиенту понять, как с ним можно взаимодействовать.

OPTIONS - служит для получения параметров для ресурса или для сервера в целом и при этом сам ресурс ни как не затрагивается (то есть это более дешевая операция по сравнению с HEAD)
OPTIONS возвращает параметры в заголовке. Список параметров зависит от ресурса и/или сервера. Обычно это заголовок Allow, который описывает какие методы доступны для ресурса.


CORS (Cross-Origin Resource Sharing) — это стандарт, позволяющий предоставлять веб-страницам доступ к объектам сторонних интернет-ресурсов.   
Сторонним считается любой интернет-ресурс, который отличается от запрашиваемого протоколом, доменом или портом. Доступ предоставляется по специализированным запросам.   
Интернет-ресурс, принимающий запрос, содержит список доверенных источников, которым разрешён доступ к объектам. Страница-источник запроса получает доступ, если входит в список доверенных источников.  
CORS нужен для обеспечения безопасности и защиты пользователей от злоумышленников при использовании HTTP-протокола. 


2. Прочитать и описать ключевые особенности "HTTP" Версии 2.0 и 3.0

HTTP/3 — готовящаяся к стандартизации версия протокола HTTP (HyperText Transfer Protocol). Главное его отличие от предыдущих версий в том, что он использует новый транспортный протокол QUIC, и за счёт этого передаёт данные быстрее.
Ключевые особенности HTTP 2.0:
•	Мультиплексирование запросов. Позволяет отправлять запросы и получать ответы асинхронно, то есть выполнять несколько запросов одновременно, используя одно соединение.  
•	Приоритизация запросов. Можно установить числовую приоритетность в пакете запросов, чтобы указать, в каком порядке ожидать ответы.  
•	Автоматическое сжатие. HTTP 2.0 выполняет сжатие GZip автоматически.  
•	Сброс соединения. Функциональность позволяет по какой-либо причине закрыть соединение между сервером и клиентом, немедленно открыв новое.  
•	Серверная отправка. Чтобы сервер не получал много запросов, в HTTP 2.0 введена эта функция: сервер пытается предсказать ресурсы, которые будут запрошены в ближайшее время, и предварительно помещает эти ресурсы в клиентский кэш.  
•	Бинарный протокол. HTTP 2.0 кодирует сообщения запроса и ответа в двоичном виде, заменив предыдущие версии обычного текста HTTP.  

Ключевые особенности HTTP 3.0:
Итак, главное преимущество HTTP/3 над HTTP/2 в том, что он быстрее за счёт использования QUIC:
•	Ускоренное соединение. Транспортный протокол QUIC использует взаимный обмен приветствиями уменьшенной длины в сравнении с TCP, поэтому передача данных начинается быстрее.  
•	Уменьшение задержки. Транспортный протокол оптимизирован для работы в условиях нестабильного интернета.  
•	Высокая пропускная способность. QUIC более эффективно использует возможности сети, даже если происходят потери пакетов.  
Повышенная безопасность. Используется шифрование TLS 1.3, что делает передачу данных более безопасной. 
•	Если часть данных в каком-то пакете была утеряна, QUIC не будет передавать весь пакет заново. Он отправит только утерянный фрагмент.
Потеря информации влияет на доставку только того потока, к которому эта информация относилась. Все остальные потоки данных продолжают передаваться без остановки.

QUIC (Quick UDP Internet Connection) — транспортный протокол, основанный на UDP. Был разработан Google в 2012 году.
QUIC включает в себя TLS 1.3, обеспечивает безопасное зашифрованное соединение, но при этом не требует такого количества «рукопожатий» как в TCP- и TLS-соединении.
Зашифрованное соединение устанавливается сразу. «Рукопожатие» проходит за 3 шага. А если это повторное соединение, то первые данные отправляются одновременно с «рукопожатием».
Всё это позволяет QUIC передавать данные в несколько раз быстрее TCP и при этом обеспечивать высокий уровень безопасности.



3. Прочитать про способы отмены запроса, включая объект "AbortController"

Один из способов отмены запроса — использование стандартного API AbortController. Он предоставляет механизм для отмены любых асинхронных операций, включая запросы на сервер.  
Чтобы использовать AbortController, необходимо создать его экземпляр и передать в качестве параметра запроса. Для этого используется метод signal. Чтобы отменить запрос, нужно вызвать метод abort() на экземпляре.  

Один из способов отмены запроса с использованием объекта AbortController:
1.	Создать экземпляр AbortController и получить сигнал:
const controller = new AbortController();
const { signal } = controller;

2. Для отмены запроса вызвать метод abort контроллера: 
controller.abort()

Пример использования с Fetch API: 
const controller = new AbortController();
const { signal } = controller;
// Отмена запроса через 1 секунду
setTimeout(() => controller.abort(), 1000);
fetch("http://localhost:8000", { signal }).then(() => { console.log("Response received"); }).catch(error => { console.log("An error occurred"); });

Следует помнить, что не все браузеры и окружения поддерживают AbortController. Перед его использованием рекомендуется проверять наличие поддержки. 

Ещё один способ — использование промисов и async/await. При использовании этих технологий можно использовать Promise.race, чтобы создать гонку между промисом запроса и промисом отмены. Как только промис отмены выполнится первым, можно будет обработать отмену запроса.  
Также некоторые HTTP-клиенты, например Axios, предоставляют встроенные методы для отмены запросов. 
Axios - популярная библиотека для создания HTTP-запросов на JavaScript. Она предоставляет простой в использовании интерфейс и поддерживает множество функций, таких как перехват запросов и ответов, автоматические повторные попытки и многое другое. Чтобы отменить запрос, отправляемый с помощью Axios, мы можем использовать CancelToken функцию.
CancelToken Функция предоставляет способ отменить запросы Axios путем создания нового CancelToken объекта и передачи его в cancelToken опцию объекта конфигурации запроса Axios. Затем, когда мы захотим отменить запрос, мы можем вызвать cancel() метод CancelToken объекта.

Для отмены запроса, отправляемого с помощью XMLHttpRequest, можно использовать метод abort().  
Он позволяет прервать запрос, если он уже был отправлен. При этом значение свойства readyState объекта XMLHttpRequest изменяется на 0 (UNSENT), а событие readystatechange не возникает. 
Синтаксис использования: 
XMLHttpRequest.abort()



4. Подготовить устный ответ на вопрос, что если обратиться к переменным созданным через let, const до их объявления - мы получаем ReferenceError? 

Попытавшись обратиться к let или const-переменной до ее объявления, мы получаем ошибку, и происходит это из-за временной мертвой зоны (temporal dead zone, TDZ).
TDZ начинается в начале области видимости переменной и заканчивается ее объявлением. Обращение к переменной в TDZ приводит к выбросу ReferenceError.
Вот пример понятного блока, показывающего начало и конец временной мертвой зоны foo:

{
   // Начало TDZ для foo
    let bar = 'bar';
  console.log(bar); // "bar"
  console.log(foo); // ReferenceError, потому что мы в  TDZ
  let foo = 'foo';  // Конец TDZ для foo
}

 5.

const myPrompt = () => {
    const answer1 = prompt('введите число:');
    let number = Number(answer1);
const answer2 = prompt('Введите систему счисления для числа');
let numberSystem = Number(answer2);

   if (answer1 === null || answer2 === null) {
        alert('Ввод отменен!');
        return;
    }

if (!Number.isInteger(number)) {
  alert('Некорректный ввод!');
  return
} 

 if (!Number.isInteger(numberSystem) || numberSystem < 2 || numberSystem > 36) {
        alert('Некорректный ввод');
        return;
    }

    let result = parseInt(number).toString(numberSystem);
    alert(`Ответ: число ${number} в ${numberSystem}-ой системе счисления = ${result} `)
}

myPrompt()

6. const res = "B" + "a" + (1 - "hello");
console.log(res); // BaNaN

Если из числа вычесть строку, будет NaN.
Когда прибавляем к строке NaN, он тоже превращается в строку.


const res2 = (true && 3) + "d";
console.log(res2); // 3d

3 == true 
true && 3 выводит последний true результат (3)
3 + "d" == 3d


const res3 = Boolean(true && 3) + "d";
console.log(res3); // trued
